package JavaCollections.Queue;

import java.util.concurrent.ArrayBlockingQueue; // Импортируем ArrayBlockingQueue
import java.util.concurrent.BlockingQueue;      // Импортируем интерфейс BlockingQueue


/* ArrayBlockingQueue — это класс в Java, который реализует интерфейс BlockingQueue.
Он предоставляет реализацию очереди, использующую массив фиксированного размера для хранения элементов.
 Это позволяет производить потокобезопасную работу с очередью в многопоточных приложениях.

### Основные характеристики ArrayBlockingQueue:

1. Фиксированный размер:
- При создании экземпляра ArrayBlockingQueue необходимо указать максимальный размер очереди.
 Это означает, что не может быть добавлено больше элементов, чем указано.

2. Потокобезопасность:
- ArrayBlockingQueue является потокобезопасной реализацией, что означает, что несколько потоков могут безопасно добавлять
 и удалять элементы одновременно.

3. Блокировка:
- Методы добавления и удаления блокируют выполнение потоков, если очередь полна (для добавления) или пуста
 (для удаления), до тех пор, пока элементы не станут доступны. Это позволяет эффективно управлять потоками.

4. Методы:
- boolean offer(E e): Добавляет элемент в очередь, если это возможно, не блокируя поток. Возвращает false,
 если очередь полна.
- void put(E e): Добавляет элемент в очередь, блокируя поток, если очередь полна, до тех пор, пока место не освободится.
- E take(): Извлекает и удаляет элемент из очереди, блокируя поток, если очередь пуста, до тех пор, пока не станет
 доступны элементы.
- E poll(long timeout, TimeUnit unit): Извлекает и удаляет элемент, дожидаясь его появления в течение указанного времени.
 Возвращает null, если время истекло без появления элемента.

5. Производительность:
- ArrayBlockingQueue обладает хорошими характеристиками по производительности для приложений,
 где нужно строго контролировать политику блокировки и размер очереди.

6. Использование:
- Широко используется в многопоточных приложениях, таких как реализация пула потоков, а также в сценариях,
 где требуется устойчивый и контролируемый доступ к ресурсам между потоками. */


public class ArrayBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // Создаем экземпляр ArrayBlockingQueue с размером 5
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

        // Добавление элементов в очередь
        queue.offer("Task 1"); // Добавляем элемент без блокировки
        queue.offer("Task 2"); // Добавляем элемент без блокировки
        queue.offer("Task 3"); // Добавляем элемент без блокировки

        // Получение элемента из начала очереди
        String first = queue.peek(); // Получаем, но не удаляем первый элемент
        System.out.println("First task in the queue: " + first);

        // Удаление элемента из начала очереди
        String dequeued = queue.poll(); // Удаляем и возвращаем первый элемент
        System.out.println("Dequeued task: " + dequeued);

        // Заполнение очереди
        queue.put("Task 4"); // Блокируем, пока не освободится место
        queue.put("Task 5"); // Блокируем, пока не освободится место

        // Очередь заполнена, следующая попытка добавления будет блокировать до освобождения места
        // Пример использования блока
        System.out.println("Attempting to add Task 6...");
        new Thread(() -> {
            try {
                Thread.sleep(2000); // Задержка перед добавлением
                queue.put("Task 6"); // Добавление после ожидания
                System.out.println("Task 6 has been added.");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // Перебор элементов в очереди
        System.out.println("Tasks in the queue:");
        for (String task : queue) {
            System.out.println(task); // Выводим каждый элемент
        }

        // Проверка размера очереди
        int size = queue.size(); // Получаем количество элементов в очереди
        System.out.println("Size of the queue: " + size);

        // Очистка очереди
        queue.clear(); // Удаляем все элементы из очереди
        System.out.println("Queue after clearing: " + queue);
    }
}
